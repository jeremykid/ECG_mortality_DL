# -*- coding: utf-8 -*-
"""ECG_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aAxVJfGql4eJztdRr27Y30BTsEX3puEb
"""

import torch
from torch import Tensor
import torch.nn as nn
try:
    from torch.hub import load_state_dict_from_url
except ImportError:
    from torch.utils.model_zoo import load_url as load_state_dict_from_url

from typing import Type, Any, Callable, Union, List, Optional


# from __future__ import print_function, division

import torch.optim as optim
from torch.optim import lr_scheduler
import torch.backends.cudnn as cudnn
import numpy as np
import pandas as pd
import re

import torchvision
from torchvision import datasets, models, transforms
import matplotlib.pyplot as plt
import time
import sys, os
import copy

# from ignite.engine import *
# from ignite.handlers import *
# from ignite.metrics import *
# from ignite.utils import *
# from ignite.contrib.metrics.regression import *
# from ignite.contrib.metrics import *

from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as f
from multiprocessing import Process
import gzip

import torchtuples as tt


cudnn.benchmark = True

class ECG_Dataset_raghunath_Diagonal_labels(Dataset):
    '''
    Diagnosis labels
    '''
    def __init__(self, df, transform=None, age_sex_path_df = None, 
                 diago_df = None, y = None,
                 np_path = "/home/padmalab/ecg/data/processed/ecgs_compressed/ecgs_np/%s.xml.npy.gz"):
        self.ecg_df = df
        self.transform = transform
        self.diago_df = diago_df
        self.age_sex_path_df = age_sex_path_df
        self.y = y
        self.np_path = np_path
        
    def __len__(self):
        return len(self.ecg_df)
    
    def __getitem__(self, idx):
        if torch.is_tensor(idx):
            idx = idx.tolist()
        
        row = self.ecg_df.iloc[idx]
        base_name = row.path
        
        # 1 get leads                        
        try: 
            np_path = self.np_path%base_name
            f = gzip.GzipFile(np_path, "r")
            enp = np.load(f)[:,0:5040]
        except Exception as e:
            enp = np.zeros([12,5040])
            pass
            
        try:
            as_measures = self.age_sex_path_df.loc[base_name]
            as_measures = as_measures.to_numpy()
            # as_measures = as_measures.astype(np.float)
        except Exception as e:
            # print (e)
            as_measures = np.array([50, 1])
            
        y = self.y.loc[base_name]
            
        sample = {
                "path": base_name,
                "y": torch.FloatTensor(y),# y.to_numpy(),
                "leads": torch.FloatTensor(enp),
                "agsx": as_measures.astype(np.float32),
                }
        if self.transform:
            sample = self.transform(sample)
        return tt.tuplefy(sample["path"], (sample['leads'],sample['agsx']), sample['y'])

class ModelA(nn.Module):
    def __init__(
        self,
    ):
        super(ModelA, self).__init__()
        self.conv1 = nn.Conv1d(3, 3, kernel_size=2521, stride=1, padding=0, bias= False)
        self.bn1 = nn.BatchNorm1d(3)   
        self.relu1 = nn.ReLU() 

        self.conv2 = nn.Conv1d(3, 16, kernel_size=1261, stride=1, padding=0, bias= False)
        self.bn2 = nn.BatchNorm1d(16)   
        self.relu2 = nn.ReLU()

        self.conv3 = nn.Conv1d(16, 32, kernel_size=631, stride=1, padding=0, bias= False)
        self.bn3 = nn.BatchNorm1d(32)   
        self.relu3 = nn.ReLU()

        self.conv4 = nn.Conv1d(32, 64, kernel_size=316, stride=1, padding=0, bias= False)
        self.bn4 = nn.BatchNorm1d(64)   
        self.relu4 = nn.ReLU()

        self.conv5 = nn.Conv1d(64, 128, kernel_size=158, stride=1, padding=0, bias= False)
        self.bn5 = nn.BatchNorm1d(128)   
        self.relu5 = nn.ReLU()

        self.conv6 = nn.Conv1d(128, 256, kernel_size=1, stride=1, padding=0, bias= False)
        self.bn6 = nn.BatchNorm1d(256)   
        self.relu6 = nn.ReLU()

        self.conv7 = nn.Conv1d(256, 512, kernel_size=1, stride=1, padding=0, bias= False)
        self.bn7 = nn.BatchNorm1d(512)   
        self.relu7 = nn.ReLU()

        self.pool = nn.AvgPool1d(158, stride=1)

    def forward(self, signal):
        # print('Signal', signal.shape)
        x1 = self.conv1(signal)
        x1 = self.bn1(x1)
        x1 = self.relu1(x1)
        # print('1st',x1.shape)
        x1 = self.conv2(x1)
        x1 = self.bn2(x1)
        x1 = self.relu2(x1)
        # print('2nd',x1.shape)
        x1 = self.conv3(x1)
        x1 = self.bn3(x1)
        x1 = self.relu3(x1)
        # print('3rd',x1.shape)
        x1 = self.conv4(x1)
        x1 = self.bn4(x1)
        x1 = self.relu4(x1)
        # print('4th',x1.shape)
        x1 = self.conv5(x1)
        x1 = self.bn5(x1)
        x1 = self.relu5(x1)
        # print('5th',x1.shape)
        x1 = self.conv6(x1)
        x1 = self.bn6(x1)
        x1 = self.relu6(x1)
        # print('6th',x1.shape)
        x1 = self.conv7(x1)
        x1 = self.bn7(x1)
        x1 = self.relu7(x1)
        # print('7th',x1.shape)
        x1 = self.pool(x1)
#         print('avgPool1d',x1.shape)

        x1 = torch.flatten(x1, start_dim=1)
        # print('GAV', x1.shape)
        return x1

'testing the ModelA'
model = ModelA()
def test():
    N, in_channels, z = 8, 3, 5040
    x = torch.randn((N, in_channels, z))
    print(model(x).shape) # (8, 512)
    print("Success")
    
test()

class ModelB(nn.Module):
    def __init__(
        self,
    ):
        super(ModelB, self).__init__()
        self.conv1 = nn.Conv1d(3, 3, kernel_size=625, stride=1, padding=0, bias= False)
        self.bn1 = nn.BatchNorm1d(3)   
        self.relu1 = nn.ReLU() 

        self.conv2 = nn.Conv1d(3, 64, kernel_size=313, stride=1, padding=0, bias= False)
        self.bn2 = nn.BatchNorm1d(64)   
        self.relu2 = nn.ReLU()

        self.conv3 = nn.Conv1d(64, 128, kernel_size=157, stride=1, padding=0, bias= False)
        self.bn3 = nn.BatchNorm1d(128)   
        self.relu3 = nn.ReLU()

        self.conv4 = nn.Conv1d(128, 256, kernel_size=1, stride=1, padding=0, bias= False)
        self.bn4 = nn.BatchNorm1d(256)   
        self.relu4 = nn.ReLU()

        self.conv5 = nn.Conv1d(256, 512, kernel_size=1, stride=1, padding=0, bias= False)
        self.bn5 = nn.BatchNorm1d(512)   
        self.relu5 = nn.ReLU()

        self.pool = nn.AvgPool1d(156, stride=1)

    def forward(self, signal):
        # print('Signal', signal.shape)
        x1 = self.conv1(signal)
        x1 = self.bn1(x1)
        x1 = self.relu1(x1)
        # print('1st',x1.shape)
        x1 = self.conv2(x1)
        x1 = self.bn2(x1)
        x1 = self.relu2(x1)
        # print('2nd',x1.shape)
        x1 = self.conv3(x1)
        x1 = self.bn3(x1)
        x1 = self.relu3(x1)
        # print('3rd',x1.shape)
        x1 = self.conv4(x1)
        x1 = self.bn4(x1)
        x1 = self.relu4(x1)
        # print('4th',x1.shape)
        x1 = self.conv5(x1)
        x1 = self.bn5(x1)
        x1 = self.relu5(x1)
        # print('5th',x1.shape)
        x1 = self.pool(x1)
        x1 = torch.flatten(x1, start_dim=1)
        # print('GAV', x1.shape)
        return x1

class FinalModel(nn.Module):
    def __init__(
        self,
        dropout_keep_prob = 0.8
    ):
        super(FinalModel, self).__init__()
        self.dense_agsx = nn.Linear(2,64)
        self.dense1 = nn.Linear(2624,256)
        self.dense2 = nn.Linear(256, 128)
        self.dense3 = nn.Linear(128, 64)
        self.dense4 = nn.Linear(64, 32)
        self.dense5 = nn.Linear(32, 8)
        self.dense6 =  nn.Linear(8,1)
        self.sigmoid = nn.Sigmoid()
        self.dropout_rate = 1 - dropout_keep_prob
        self.drop = nn.Dropout(p=self.dropout_rate)
        self.MA = ModelA()
        self.MB1 = ModelB()
        self.MB2 = ModelB()
        self.MB3 = ModelB()
        self.MB4 = ModelB()
    def forward(self, agsx, signalA, signalB1, signalB2, signalB3, signalB4):
        # print('*****************FinalModel****************')
        x_agsx = self.dense_agsx(agsx)
        # print('agsx', x_agsx.shape)
        x1 = self.MA(signalA)
        # print('x1', x1.shape)
        x2 = self.MB1(signalB1)
        # print('x2', x2.shape)
        x3 = self.MB2(signalB2)
        # print('x3', x3.shape)
        x4 = self.MB3(signalB3)
        # print('x4', x4.shape)
        x5 = self.MB4(signalB4)
        # print('x5', x5.shape)
        concat = torch.cat((x_agsx,x1,x2,x3,x4,x5),1)
        # print('concat', concat.shape)
        dense = self.dense1(concat)
        dense = self.drop(dense)
        # print('dense1', dense.shape)
        dense = self.dense2(dense)
        dense = self.drop(dense)
        # print('dense2', dense.shape)
        dense = self.dense3(dense)
#         dense = self.drop(dense)
        # print('dense3', dense.shape)
        dense = self.dense4(dense)
#         dense = self.drop(dense)
        # print('dense4', dense.shape)
        dense = self.dense5(dense)
#         dense = self.drop(dense)
        # print('dense5', dense.shape)
        dense = self.dense6(dense)
#         dense = self.drop(dense)
        # print('dense6', dense.shape)
        sigmoid = self.sigmoid(dense)
        # print('sigmoid',sigmoid.shape)
        return sigmoid

'testing the ModelB'
model = FinalModel()
def test():
    x1 = torch.randn((8, 2))
    x2 = torch.randn((8, 3, 5040))
    x3 = torch.randn((8, 3, 1248))
    x4 = torch.randn((8, 3, 1248))
    x5 = torch.randn((8, 3, 1248))
    x6 = torch.randn((8, 3, 1248))
    m = model(x1, x2, x3, x4, x5, x6)
    print("Success")
    
# test()







